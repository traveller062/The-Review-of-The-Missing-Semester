# The-Review-of-The-Missing-Semester
> 一个记录The Missing Semester课程的记录

# 课程目录

![](source/课程目录 1.png)

##  A.==课程概览与 shell==(Course overview + the shell)

**介绍shell的定义，用途与基本命令行指令**（有部分个人的补充）

### shell的定义

Shell 是一个程序，它从键盘接收命令并将其传递给操作系统执行。启动终端时，我们会看到一个提示符，这就是 shell 的主要文本界面，这门课主要使用Bash shell教学。

我使用的是WSL安装的Ubuntu。
### 提示符
当 Shell 加载完毕时，会显示一个提示符
```Bash
用户名@机器名:当前路径$
```

**$与#**
- 如果在初始化意外退出，可能会在再次加载时默认为#（root用户）

- root 是系统的超级用户或管理员。它拥有系统的最高权限，可以绕过所有的权限检查，对系统上的任何文件进行任何操作。正因如此，直接以 root 身份进行日常操作是极其危险的。

- “#”标识着当前处于ROOT用户，拥有所有权限，因此容易出现无法挽回错误操作，建议首先转为"$"用户（正常用户），让操作更加安全。

### 通配符

#### **“\*”**
代表 **“零个”** 或 **“任意多个”** 任意字符。

- **后缀匹配 (最常用)**
    
    - **命令**：`ls *.txt`
        
    - **含义**：列出所有以 `.txt` 结尾的文件。
        
    - **匹配**：`a.txt`, `log.txt`, `.txt` (如果文件名就是 .txt)
        
    - **不匹配**：`a.doc`, `a.txt.bak`
        
- **前缀匹配**
    
    - **命令**：`rm backup*`
        
    - **含义**：删除所有以 `backup` 开头的文件。
        
    - **匹配**：`backup`, `backup_2023`, `backup.zip`
        
- **包含匹配**
    
    - **命令**：`ls *config*`
        
    - **含义**：列出文件名里只要包含 `config` 这个词的文件。
        
    - **匹配**：`myconfig`, `config.json`, `sys_config_old`
        
- **全部匹配 (危险)**
    
    - **命令**：`rm *`
        
    - **含义**：删除当前目录下**所有**可见文件（不包含隐藏文件）。
        
    - **注意**：慎用！

#### **"\?"**(占位符)
代表 **“正好 1 个”** 任意字符

- **限制长度** 假设你有 `file1.txt`, `file2.txt`, `file10.txt`。
    
    - **命令**：`ls file?.txt`
        
    - **匹配**：`file1.txt`, `file2.txt`
        
    - **不匹配**：`file10.txt`。

#### **"\[]"**
匹配方括号内指定的**任意一个**字符

- `ls file[123].txt` -> 只匹配 `file1.txt`, `file2.txt`, `file3.txt`。
    
- `ls file[a-z].txt` -> 匹配 file 加任意一个小写字母。


### 常用命令

#### 类型可分为==无参数命令==和==带参数命令==

 ```Bash
 date
 //无参数命令，将输出系统中的时间数据
 
 echo hello
 hello
 //带参数命令，echo将在终端打印参数
 ```

处理带空格参数

| 方法                       | 描述                                                 | 示例                 |
| ------------------------ | -------------------------------------------------- | ------------------ |
| **双引号 (**  **"**  **)**  | 将多个单词包裹起来，视为一个完整的参数。功能与单引号类似，但会处理内部的特殊字符（变量扩展 $等）。 | echo "hello world" |
| **单引号 (**  **'**  **)**  | **完全忽略** 内部的所有特殊字符，所有内容均被视为纯文本字符串。                 | echo 'hello world' |
| **反斜杠转义 (**  _\\_  **)** | 仅对紧随其后的单个字符进行转义，使其失去特殊含义。                          | echo hello\ world  |
|                          |                                                    |                    |
**注意**：不处理带空格参数，容易被当作是多个独立的字符串处理
```
mkdir my photo
//会创建 my , photo 2个文件夹
```

#### pwd
显示当前工作目录

```Bash
pwd
/home/username/source (在source时)

```

#### which
可以搜索程序储存在哪里
```Bash
which echo
/usr/bin/echo
```

#### man
可以找到命令行的文档帮助
```Bash
man ls
//查找ls相关教程
man
//查看所有教程
```
#### ls
列出目录内容

```Bash
ls  (在/目录下) 简单列出目录名字
bin   dev  home  lib    lib64   lost+found  mnt  proc  run   snap  sys  usr
boot  etc  init  lib32  libx32  media       opt  root  sbin  srv   tmp  var

ls -l 同时列出总量，使用权限，修改时间等
total 2784
lrwxrwxrwx   1 root root       7 May 31  2023 bin -> usr/bin
drwxr-xr-x   2 root root    4096 May 31  2023 boot
drwxr-xr-x  15 root root    3860 Jan 12 11:15 dev
...
r:read
w:write
x:execute

ls --help
可以查看ls的文档帮助

```


| **权限**     | **对文件**                                     | **对目录 **                                       |     |
| ---------- | ------------------------------------------- | ---------------------------------------------- | --- |
| **r (读)**  | **查看内容**<br>(例如用 `cat`, `vim` 打开看里面的文字)<br> | **列出内容**<br>(可以使用 `ls` 命令查看目录下有哪些文件)           |     |
| **w (写)**  | **修改内容**<br>(可以编辑、保存、清空文件内容)                | **修改目录结构**<br>(可以在该目录下**新建**、**删除**、**重命名**文件) |     |
| **x (执行)** | **运行程序**<br>(可以作为脚本或程序运行，如 `.sh` 或 `.exe`)  | **进入目录**<br>(可以使用 `cd` 命令进入该目录)                |     |
|            |                                             |                                                |     |

```
drwxr-xr-x 2 john john 4096 Oct 26 10:30 my_dir

● d...: 第一个字符代表文件类型（d 代表目录，- 代表普通文件）。

● rwxr-xr-x: 接下来的九个字符是权限字符串，分为三组：

● rwx: 文件 **所有者**  (john) 的权限。

● r-x: 文件所属 **用户组**  (john) 的权限。

● r-x:  **其他所有人** 的权限。

● 2: 链接数。

● john: 文件所有者。

● john: 文件所属组。

● 4096: 文件大小（字节）。

● Oct 26 10:30: 最后修改时间。

● my_dir: 文件名。
```

```
要成功访问一个文件（例如 cat /home/user/report.txt），您必须拥有对路径上每一个父目录（即 /、/home 和 /home/user）的 执行  权限。缺少任何一级目录的 x 权限，都将导致您无法 "进入" 该目录，从而无法访问其下的任何内容。
```
#### cd
切换当前位置

可以用**相对路径**或者**绝对路径**

快捷键
●  .   **(当前目录)** : 代表您目前所在的目录。

● ..  **(父级目录)** : 代表当前目录的上一级目录。例如，cd .. 会将您带到父目录。

● ~  **(用户主目录)** : 一个快捷方式，代表当前用户的主目录（例如 /home/john）。

● cd -  **(切换回上一个目录)** : 这是一个非常实用的技巧，可以在您刚刚离开的目录和当前目录之间快速切换。


#### cat和touch

cat可以读取文件中的内容
```hello.txt
hello
```

```Bash
cat hello.txt
hello
```


touch 如果不存在输入的文件名的文件则创建一个，如果存在则更改时间戳
```
touch hello.txt
//创建了一个hello.txt的文件
```

#### $PATH
可以使用 echo 命令来查看 PATH 设置：
```Bash
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

#### mkdir

用于创建文件夹
```Bash
mkdir document
//创建一个名字为document的文件夹

mkdir -p document/source
可以一次性创建嵌套的多层目录（文件夹）
```

#### cp

复制文件或目录

```Bash
cp hello.txt hello1.txt
//将原有的hello.txt 里的所有内容复制给hello1.txt

//如果hello1.txt不存在则创建一个并复制内容，如果存在hello1.txt，则原有内容清空并复制hello.txt中的内容

cp -r attempt1 attempt2
//将attempt1中所有文件全部复制给attempt2,并不会覆盖attempt2原有的文件，新的文件的文件名和attempt1中的文件名一样
```

#### mv
移动或重命名文件/目录，既可用于重命名文件（mv old new），也可用于将其移动到不同目录

```Bash
mv file1 file2
//如果2个文件存在，则file2内容被清空后，填充file1内容，并file1消失（与cp不同之处）
//如果file2不存在，相当于将file1的文件名改为file2的文件名

换成文件夹时

mv dir1 dir2
如果两个文件夹都存在，则dir1移动到dir2中
dir2不存在，则是常见的重命名

mv bin ../
//将本目录中的bin文件移动到上一级目录中
```

#### rm

```Bash
rm file
//删除文件

rm * 
//删除文件夹中所有文件（文件夹中的文件夹不会被删除）

rm -r dir
//删除文件夹，此操作极具风险，无法撤销。

tip:
rmdir
// 删除空目录,作为一个安全措施，防止误删非空目录
```

#### less与tail ,head,wc -l
- **`cat`**: 一次性看完（适合小文件）
- **`less`**: 翻页查看（适合大日志）
- **`tail -f`**: 实时盯着文件尾部看（专门用来盯日志更新）

**less**
```Bash
less 文件名

上一个命令 | less

 `Space` (空格键)：向下翻一页。  
 `b` (Back)：向上翻一页。   
 `Enter` (回车)：向下滚一行。   
 `/关键词`：在文件内搜索（输入后按 `n` 跳转下一个匹配项）。
 `q` (Quit)：退出 (最重要的键！)。
 
```

**tail**
```Bash
tail 文件名

-n 数字：显示最后的多少行（默认是 10 行）。
-n 1
-f ：实时监控。不会退出，而是等待文件更新，一旦有新日志写入，立刻显示在屏幕上。
```

**head**
查看文件**开头**的内容
```Bash
head -n 5 data.txt
```

**wc**

计行数。`wc` 可以统计字节、单词，但 90% 的情况我们只用 `-l` (lines) 来统计**有多少行**。

```Bash

# 1. 统计这个文件一共有多少行
wc -l names.txt

# 2. 组合拳：统计当前目录下有多少个 jpg 图片
ls -l | grep ".jpg" | wc -l
```

#### sudo

提供了一种更安全的方式来执行需要管理员权限的操作。它允许普通用户 **临时以**  **root**  **身份执行单个命令** ，而无需完全切换到 root 用户

| **需求**              | **核心命令**                |
| ------------------- | ----------------------- |
| **单次提升权限** (标准用法)   | `sudo 命令`               |
| **忘了加 sudo** (补救)   | `sudo !!`               |
| **变成 root** (连续操作)  | `sudo -i` (用完记得 `exit`) |
| **修改 sudo 配置** (安全) | `sudo visudo`           |
| 在root下使用普通用户        | `sudo -u username  `    |
**失败分析**
```Bash
sudo echo "value" > /path/to/protected_file
```

**原因 ：命令的解析是由当前的 Shell**  完成的，而不是由 sudo。

1. 在 sudo 命令 **执行之前** ， Shell（以普通用户身份运行）首先会解析整个命令。

2. Shell 发现了重定向符号 >，并尝试立即打开 /path/to/protected_file 文件。

3. 由于普通用户没有写入权限，因此 Shell 立即报错。

**解决方法**
确保打开受保护文件进行写入的操作是由一个拥有 root 权限的进程来执行的。这可以通过管道和 tee 命令实现**工作原理** ：

```Bash
echo "value" | sudo tee /path/to/protected_file
```

1. echo "value" 以普通用户身份运行，并将其输出 "value" 发送到管道。

2. sudo tee ... 命令以 root 权限启动。

3. tee 程序从管道中读取 "value"，并尝试将其写入 /path/to/protected_file。


- `tee` 命令的作用是从管道接收数据
    
    1. 把数据**显示在屏幕上**（标准输出）。
        
    2. 把数据**写入到指定文件**中。




#### grep

查找。它用于从大量文本中**筛选**出你想要的那些行。

```Bash
grep "关键词" 文件名
```

**常用参数 ：**

`-i` ：**忽略大小写**。不管是 "Error", "error" 还是 "ERROR" 都能搜到。
`-v` ：**反选/排除**。显示**不包含**关键词的行
`-r` ：**递归搜索**。在文件夹里搜，不仅搜当前目录，还搜子目录下的文件。

#### 其他技巧

**Ctrl + L**  清屏

**xgd-open** **(Linux)使用系统默认的应用程序打开一个文件或目录
tip:但如果是WSL的Ubuntu的话没有此功能，可以用wslview平替
或者直接调用 `explorer.exe`


### shell的流，重定向和管道

#### 流
每个在 Shell 中运行的程序都默认拥有两个主要的通信渠道，即“流”：

● **标准输入 (stdin)** : 程序接收数据的通道，默认连接到您的键盘。

● **标准输出 (stdout)** : 程序发送结果的通道，默认连接到您的终端屏幕。

#### 重定向

重定向允许您改变这些默认的数据流向，例如，将程序的输出保存到文件，或从文件读取输入。

| 操作符 | 名称 | 功能描述 | 示例 |
| ------ | ------ | ------ | ------ |
| > | 输出重定向（覆盖） | 将命令的输出写入文件，如果文件已存在则 **覆盖** 其内容。 | echo "Hello" > greeting.txt |
| >> | 输出重定向（追加） | 将命令的输出 **追加** 到文件末尾，不覆盖原有内容。 | echo "World" >> greeting.txt |
| < | 输入重定向 | 从文件读取内容作为命令的输入。 | cat < greeting.txt |

**双通道**：

**标准输出 ( 代码 1)**：程序的**正常**运行结果。
`>` 默认只接管这条路。   

2**标准错误 ( 代码 2)**：程序的**报错**信息。
`>` 默认不管这条路，所以报错依然会漏到屏幕上。
```Bash
# 把所有输出（不管对错）都写进 log.txt
python script.py > log.txt 2>&1

# 查找文件，如果有报错直接扔掉，不显示
find / -name "test.txt" 2> /dev/null(专门处理废物输出)

#快速清空大文件
> big_file.log
```

| **符号**          | **作用** | **口诀**           |
| --------------- | ------ | ---------------- |
| **`>`**         | 覆盖写入   | **喜新厌旧** (旧的被删掉) |
| **`>>`**        | 追加写入   | **多多益善** (接在后面写) |
| **`2>`**        | 只存报错   | **报喜不报忧** (反向)   |
| **`2>&1`**      | 全部保存   | **我全都要**         |
| **`/dev/null`** | 丢弃数据   | **无底黑洞**         |

#### 管道 (|)

管道 (|) 的作用是将符号左边命令的 标准输出   直接连接到右边命令的 标准输入。

### shell控制系统浅探

/sys 是一个非常特殊的虚拟文件系统。它并非存储在硬盘上，而是内核将其内部参数和状态以文件的形式暴露出来。可以使用 Shell 工具（如 cat, echo）来读取甚至修改内核的运行时参数。

shell可以直接与硬件交互。

● **修改屏幕亮度** 
```

echo 500 | sudo tee /sys/class/backlight/intel_backlight/brightness
```

● **点亮键盘上的 Scroll Lock LED 灯** ： 
```

echo 1 | sudo tee /sys/class/leds/input3::scrolllock/brightness
```

